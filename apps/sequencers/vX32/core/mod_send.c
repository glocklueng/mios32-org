/* $Id:  $ *//*vX32 pre-alphanot for any use whatsoevercopyright stryd_onebite me corp 2008big props to nILS for being my fourth eye and TK for obvious reasons
stay tuned for UI prototyping courtesy of lucem!
*//////////////////////////////////////////////////////////////////////////////// Include files/////////////////////////////////////////////////////////////////////////////#include <FreeRTOS.h>#include <portmacro.h>#include <mios32.h>#include "app.h"#include "graph.h"#include "mclock.h"#include "modules.h"#include "patterns.h"#include "utils.h"#include "ui.h"#include <seq_midi_out.h>void (*const mod_send_buffer_type[max_buffertypes]) (unsigned char nodeid) = {	&mod_send_midi,													// names of functions to send 	&mod_send_com,													// outbuffers according to type	&mod_send_dummy													// must be max_buffertypes of elements};const unsigned char mod_send_buffer_size[max_buffertypes] = {	4,																// size of buffer required 	1,																// by send function according to type	0																// must be max_buffertypes of elements};const unsigned char mod_outbuffer_type[max_moduletypes] = {	2,		//mod_proc_sclk		--> mod_send_dummy					// number of outbuffer bytes	0,		//mod_proc_seq		--> mod_send_midi					// for each module type	0,		//mod_proc_midiout	--> mod_send_midi					// must be max_moduletypes of elements	2,		//mod_proc_sxh		--> mod_send_dummy					// number of outbuffer bytes};const unsigned char mod_outbuffer_count[max_moduletypes] = {	0,		//mod_proc_sclk											// number of outbuffer bytes	3,		//mod_proc_seq											// for each module type	3,		//mod_proc_midiout										// must be max_moduletypes of elements	0,		//mod_proc_sxh											// number of outbuffer bytes};void mod_send_buffer(unsigned char nodeid) {	if ((node[nodeid].outbuffer_type) < dead_buffertype) {		mod_send_buffer_type[(node[nodeid].outbuffer_type)](nodeid);			// unititialise according to the moduletype	}	}void mod_send_midi(unsigned char nodeid) {	unsigned char i;	unsigned char count = (node[nodeid].outbuffer_req);	unsigned char size = (node[nodeid].outbuffer_size);			for (i = 0; i < count; (i += size)) {				unsigned int length;		length = (node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_LENH]) << 8;		length |= (node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_LENL]);				node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_LENH] = dead_value;		node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_LENL] = dead_value;				if ((node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_CHAN] != dead_value) &&			// Paranoia			(node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_NOTE] != dead_value) &&			(node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_VEL] != dead_value) &&			length > 0) {						u8 chan = (node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_CHAN])%16;			node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_CHAN] = dead_value;						u8 note = util_s8tou7(node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_NOTE]);			node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_NOTE] = dead_value;						u8 velocity = util_s8tou7(node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_VEL]);			node[nodeid].outbuffer[i+MOD_SEND_MIDI_NOTE0_VEL] = dead_value;						if( length ) {						// put note into queue if all values are != 0				mios32_midi_package_t midi_package;								midi_package.type     = NoteOn; 					// package type must match with event!				midi_package.event    = NoteOn;				midi_package.chn      = chan;				midi_package.note     = note;				midi_package.velocity = velocity;								SEQ_MIDI_OUT_Send(USB0, midi_package, SEQ_MIDI_OUT_OnOffEvent, mod_tick_timestamp, length);							}					}			}		(node[nodeid].outbuffer_req) = 0;}	void mod_send_com(unsigned char nodeid) {	unsigned char i;	unsigned char count = (node[nodeid].outbuffer_req);	for (i = 0; i < count; i+node[nodeid].outbuffer_size) {		if (node[nodeid].outbuffer[i] != dead_value) {			node[nodeid].outbuffer[i] = dead_value;			(node[nodeid].outbuffer_req)--;		}			}	}	void mod_send_dummy(unsigned char nodeid) {	unsigned char i;	unsigned char count = (node[nodeid].outbuffer_req);	for (i = 0; i < count; i+node[nodeid].outbuffer_size) {		if (node[nodeid].outbuffer[i] != dead_value) {			// it's a dummy, dummy 			// MIOS32_COM_SendChar(COM_USB0, util_s8tou7(node[nodeid].outbuffer[i]));			node[nodeid].outbuffer[i] = dead_value;			(node[nodeid].outbuffer_req)--;		}			}	}
