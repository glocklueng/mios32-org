// $Id$
/*
 * Trigger Layer Routines
 *
 * ==========================================================================
 *
 *  Copyright (C) 2008 Thorsten Klose (tk@midibox.org)
 *  Licensed for personal non-commercial use only.
 *  All other rights reserved.
 * 
 * ==========================================================================
 */

/////////////////////////////////////////////////////////////////////////////
// Include files
/////////////////////////////////////////////////////////////////////////////

#include <mios32.h>

#include "seq_trg.h"
#include "seq_core.h"
#include "seq_cc.h"


/////////////////////////////////////////////////////////////////////////////
// Local types
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Local prototypes
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Global variables
/////////////////////////////////////////////////////////////////////////////

u8 trg_layer_value[SEQ_CORE_NUM_TRACKS][3][SEQ_CORE_NUM_STEPS/8];


/////////////////////////////////////////////////////////////////////////////
// Local variables
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Initialisation
/////////////////////////////////////////////////////////////////////////////
s32 SEQ_TRG_Init(u32 mode)
{
  int i, track;

  // init parameter layer values
  for(track=0; track<SEQ_CORE_NUM_TRACKS; ++track) {
    // init trigger layer values
    for(i=0; i<SEQ_CORE_NUM_STEPS/8; ++i) {
      trg_layer_value[track][0][i] = track == 0 ? 0x11 : 0x00; // gate
      trg_layer_value[track][1][i] = 0x00; // accent
      trg_layer_value[track][2][i] = 0x00; // roll
    }
  }

  return 0; // no error
}


/////////////////////////////////////////////////////////////////////////////
// returns value of a given trigger layer
/////////////////////////////////////////////////////////////////////////////
s32 SEQ_TRG_Get(u8 track, u8 step, u8 trg_layer)
{
  u8 step_mask = 1 << (step % 8);
  u8 step_ix = step / 8;
  return (trg_layer_value[track][trg_layer][step_ix] & step_mask) ? 1 : 0;
}


/////////////////////////////////////////////////////////////////////////////
// returns value of assigned layers
/////////////////////////////////////////////////////////////////////////////
s32 SEQ_TRG_GateGet(u8 track, u8 step)
{
  u8 trg_assignment = seq_cc_trk[track].trg_assignments.gate;
  // gate always set if not assigned
  return trg_assignment ? SEQ_TRG_Get(track, step, trg_assignment-1) : 1;
}


/////////////////////////////////////////////////////////////////////////////
// sets value of a given trigger layer
/////////////////////////////////////////////////////////////////////////////
s32 SEQ_TRG_Set(u8 track, u8 step, u8 trg_layer, u8 value)
{
  u8 step_mask = 1 << (step % 8);
  u8 step_ix = step / 8;

  if( value )
    trg_layer_value[track][trg_layer][step_ix] |= step_mask;
  else
    trg_layer_value[track][trg_layer][step_ix] &= ~step_mask;

  return 0; // no error
}


/////////////////////////////////////////////////////////////////////////////
// sets value of assigned layers
/////////////////////////////////////////////////////////////////////////////
s32 SEQ_TRG_GateSet(u8 track, u8 step, u8 value)
{
  u8 trg_assignment = seq_cc_trk[track].trg_assignments.gate;
  return trg_assignment ? SEQ_TRG_Set(track, step, trg_assignment-1, value) : -1;
}
